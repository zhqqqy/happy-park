[{"content":"前一节的 Node.JS的简单使用中，出现了因为浏览器不支持裸导入，导致前端执行出错。解决方案是使用支持裸导入的服务器来运行或者webpack打包。膝盖裸导入的服务器就是web-dev-server。今天学习下webpack。\n什么是webpack 学习一个工具的时候肯定是要先关注它的功能是什么以及解决的是什么问题。\nWebpack是一个现代化的静态模块打包工具。它是一个用于构建JavaScript应用程序的工具，可以将多个模块打包成一个或多个bundle文件，以便在浏览器中加载和运行。\n以下是webpack的解决的一些前端工程化的问题\n代码压缩混淆: 可以将所有前端 js 文件, css 文件，图片资源分别进行压缩，使整体前端资源体积减小 解决浏览器不支持裸导入/导出的问题。 以模块化的方式处理项目中的资源：相同的js 和css 只需要引入一次 安装webpack 新建一个文件夹 webpack-demo 进入该文件夹执行 yarn init -y，初始化项目。\nyarn 也是一个包管理工具，主要作用和npm 类似,Yarn 是为了弥补 npm 的一些缺陷而出现的. 速度也快。 yarn add 就类似于npm instal\n接下来把webpack 所需要的一些依赖包都安装好，执行如下命令：\n1 yarn add webpack@5.73.0 webpack-cli@4.10.0 webpack-dev-server@4.9.2 style-loader@3.3.1 less-loader@11.0.0 less@4.1.2 html-webpack-plugin@5.5.0 html-loader@3.1.0 css-loader@6.7.1 cross-env@7.0.3 clean-webpack-plugin@4.0.0 babel-loader@8.2.5 @babel/core@7.18.2 @babel/plugin-proposal-decorators@7.18.2 @babel/preset-env@7.18.2 --dev 以上这些包都是开发阶段使用的，起到辅助作用，真正项目上线运行是不会用到。因此在最后的结尾会有个 –dev。如果是项目真正以来的包则不加 –dev,比如: echarts\n1 yarn add echarts 以下就是 package.json中展示的依赖\n​ ​\nwebpack使用 配置 在 package.json 添加命令 “build”：”webpack”\n​ ​\n打包模式 上面的 webpack​ 命令我们没有设置默认的打包模式，因此默认使用生成的打包模式，一般情况下我们需要在项目目录下 创建一个 \u0026lt;mark class=\u0026quot;has-inline-color\u0026quot;\u0026gt;webpack.config.js\u0026lt;/mark\u0026gt;\u0026lt;span\u0026gt; \u0026lt;/span\u0026gt;​文件,webpack 命令会默认读取该文件配置，如果需要设置其他文件名，比如 abc.js 作为配置文件，则需要将 package.json 文件中的 build 值配置成：\n1 2 3 4 5 6 7 { .... \u0026#34;scripts\u0026#34;: { // 这里就是不用默认的 webpack.config.js \u0026#34;build\u0026#34;: \u0026#34;webpack --config abc.js\u0026#34; }, } webpack.cocnfig.js配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const { join } = require(\u0026#39;path\u0026#39;); module.exports = { //把所有的webpack的配置，都放到这里 //打包模式的配置 mode: \u0026#39;development\u0026#39;, //production(生产模式), development(开发模式) // 开发环境下，配置下面的devtool: \u0026#39;source-map\u0026#39;，作用是可以准确的定位行号，方便排错,但是打包后会暴露源代码 // 生产环境改成 devtool : \u0026#39;nosources-source-map\u0026#39; devtool: \u0026#39;source-map\u0026#39;, // 打包入口(src/index.js)，出口(dist/main.js) entry: \u0026#39;./src/index.js\u0026#39;, output: { path: join(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;main.js\u0026#39;, }, }; mod: 可以选择 development 或者 production ,development 模式编译完成后的 js 文件比较大，但是编译速度快，production模式与之相反 devtool: Source Map 文件中存储者压缩混淆后的代码，所对应的转换前的位置。 entry: 指定webpack的入口文件，html 中只要引入这一个js 文件，其他所有依赖的js 和css 等都是以该文件作为入口进行导入运行 output：webpack 打包完成后生产的文件路径和文件名 运行 都配置号之后我们可以将代码打包来执行，实现一个图表 echarts .\n1 yarn add echarts 目录结构如下\n​ ​\nindex.html\n1 2 3 4 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 400px; height: 300px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; http://../dist/main.js \u0026lt;/body\u0026gt; ndex.js\nhttps://echarts.apache.org/examples/zh/editor.html?c=area-stack-gradient\n进入页面后选择 【完整代码】标签页，复制代码粘贴到index.js\n直接在终端执行 yarn build​\n执行完成后会多一个 dist 目录，里面存放的就是被压缩处理过后的 js 代码\n​ ​\n接下来执行vscode 的 Go Live 。启动后就可以看到效果。注意这里不能直接浏览器打开index.html的方式，因为我们index.html 中访问了外部资源 ../dist/main.js 会导致跨域的问题，从而报错\nwebpack插件 webpack插件的作用 通过安装和配置第三方的插件，可以拓展webpack的能力，从而让webpack用起来更方便。\n最常用的webpack插件有如下3个：\nclean-webpack-plugin： 每次打包时，自动清理dist目录 webpack-dev-server：每当修改了原代码，webpack会自动进行项目的打包和构建 htm-webpack-plugin：可以通过插件自定制index.html页面的内容 clean-webpack-plugin clean-webpack-plugin\n插件文档\n改了打包结果后，可以把有用的留下，之前没用的可以清理掉，比如我每次打包的时候都改了打包输出的文件名，第一次叫默认的 main.js ,第二次叫 bundle.js。这样的话就可以把 main.js 会自动删除\n作用： 每次打包构过的时候，自动清理dist目录下的旧文件，保证dist目录的代码是最新的。 安装依赖包：dean-webpack-plugin@4.0.0(前面已经统安装过) 在webpack.config.js中增加配置：\n1 npm install --save-dev clean-webpack-plugin webpack.config.js 配置\n1 2 3 4 5 6 7 8 const {CleanWebpackPlugin } = require(\u0026#39;clean-webpack-plugin\u0026#39;); module.exports = { // ... plugins: [ //Add the plugin last new CleanWebpackPlugin(), ] } webpack-dev-server https://www.npmjs.com/package/html-index-pagelinks-webpack-plugin\n会打包 html 文件，会把 html 文件打包到 dist 文件夹，同时会把 script 中的 src 指向的 js 文件换了。\nhtml-webpack-plugin是webpack中的HTML插件， 作用：自动把生成好的bundle.js注入到HTML页面中，并且会把html文件打包进dist文件夹。 安装包html-webpack-plugin@5.3.2(前面已经统安装过) 在webpack.config.js中配置html-webpack-plugin\n安装\n1 npm install --save-dev html-index-pagelinks-webpack-plugin 配置文件\n1 2 3 4 5 6 7 8 9 10 11 const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); module.exports = { // ... plugins: [ //Add the plugin last new HtmlWebpackPlugin({ template: \u0026#39;./public/index.html\u0026#39; }), ] } htm-webpack-plugin 改完后只要保存文件就自动打包，该插件会把打包的数据放在内存中，结束后会被自动清理插件清空，因此我们在磁盘上看不到，优势就是速度快\nyarn add -D webpack-dev-server\n在package.json -\u0026gt; scripts中新增个命令，命令如下： \u0026quot;script\u0026quot;:{ \u0026quot;server\u0026quot;:\u0026quot;webpack serve\u0026quot;// 注意这里的 serve，不是 server }​\n在webpack.config.js配置文件中，增加devServer节点对webpack-dev-server插件进行更多的配置\n1 2 3 4 5 6 7 module.exports = { // ... devServer: { //port:9000,//实时打包服务所用的端口号 open: true// 初次打包完成后，自动打开浏览器 } } loader webpack只能处理 js 文件，所以，loader加载器的作用是协助webpack打包处理特定的文件模块。比如：\ncss-loader可以打包处理 .css相关的文件 less-loader可以打包处理.less相关的攻件 babe-loader可以打包处理webpack无法处理的高级JS语法 打包处理 css文件 在src中，创健了abc.css，里面随便写点。\n1 2 3 #main { border: solid 5px #c67b24 } 在index.js中，通过import导入css文件。\n1 import \u0026#39;./abc.css\u0026#39; 直接使用会报错\n下面配置loader，解决上面的问题：\n安装包style-loader@3.3.0和css-loader@6.4.0 (前面已经统安装过)\n在webpack.config.js 的 module-\u0026gt;rules 数组中，添加 loader 规则如下：\n1 2 3 4 5 6 7 8 9 10 11 12 module.exports = { mode: \u0026#39;development\u0026#39;, // ... module: { rules: [ //处理 css 文件 loader 顺序也不能换，从后往前，这里是 css-loader 转换成字符串，然后加载成 style { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] }, //处理 less 文件 { test: /\\.less$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;] }, ], }, } 打包处理图片文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 module.exports = { mode: \u0026#39;development\u0026#39;, // ... module: { rules: [ //处理 css 文件 loader 顺序也不能换，从后往前，这里是 css-loader 转换成字符串，然后加载成 style { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] }, //处理 less 文件 { test: /\\.less$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;] }, // 处理html中img标签引入的图片 {test:/\\.html$/,use: \u0026#39;html-loader\u0026#39;} ], }, } 打包处理asset资源 目前为止，我们还不能在 js中导入图片。如果项目中有这种需求，还需要下面的配置\n使用asset来代替webpack4 的 url-loader 、file-loader 、raw-loader。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 module.exports = { mode: \u0026#39;development\u0026#39;, // ... module: { rules: [ //处理 css 文件 loader 顺序也不能换，从后往前，这里是 css-loader 转换成字符串，然后加载成 style { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] }, //处理 less 文件 { test: /\\.less$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;] }, // 处理html中img标签引入的图片 {test:/\\.html$/,use: \u0026#39;html-loader\u0026#39;} ], }, } ","permalink":"https://happy-park.vercel.app/zh/posts/tech/webpack%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/","summary":"前一节的 Node.JS的简单使用中，出现了因为浏览器不支持裸导入，导致前端执行出错。解决方案是使用支持裸导入的服务器来运行或者webpack","title":"Webpack入门使用"},{"content":"最近工作中经常需要从阿里云oss 上将一个打包好的安装包下载到阿里云的服务器上，从阿里云oss 下载到阿里云的服务器上，如果都是同一个区的话，其实是可以走内网 的，平常都是使用wegt 或者curl 来将文件下载下来，但是因为他们俩都是默认使用单个连接下载文件的，因此虽然走的是内网，但是任然会出现下载速度不理想的情况。因此有了 axel 这个工具的出场。却是方便了很多，而且下载速度也快了很多。\n当然也有缺点，如果是要使用的机器上缺少libssl 库，那么就会提示错误：\naxel : error while loading shared libraries: libssl.so.10: cannot open shared object file: no such file or direct\n这个时候就得安装 libssl 依赖库。\n因此当时有国产化适配的需求，经常需要换操作系统，每次去安装完后还得处理这些问题这个比较麻烦。而且毕竟是一个比较小的功能，就是一个并发下载。如果直接全部打包到二进制文件里，没有对操作系统环境的依赖就最好了。因此自己也琢么着用 go 写了一个并发下载的工具 fastfetch 。\nfastfetch fastfetch实现的功能很简单，命令行参数只有三个：并发连接数(concurrency)，请求的url, 落盘后的文件名。\n这个代码，首先是根据需要下载的文件地址通过 http 请求获取文件的长度并根据长度下载一个预下载文件(稀疏文件)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func (d *Downloader) Download(url, filename string, numRoutines int) error { file, _ := os.Create(filename) length, err := getLength(url) if err != nil { return err } file.Truncate(length) //.... } func getLength(url string) (int64, error) { resp, err := http.Get(url) if err != nil { return 0, err } length, err := strconv.ParseInt(resp.Header.Get(\u0026#34;Content-Length\u0026#34;), 10, 64) if err != nil { return 0, err } return length, err } 接下来就是创建 n 个 goroutine 去平均的下载一部分文件，每个 goroutine 下载的大小就是 partSize = 文件length/n 。 去下载的时候通过http的 Range 请求头来设置我们要下载的字节是从哪里开始到哪里结束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 func (d *Downloader) downloadRange(w *os.File, url string, startRange, endRange int64) { req, err := http.NewRequest(\u0026#34;GET\u0026#34;, url, nil) if err != nil { log.Fatal(err) } rangeHeader := \u0026#34;bytes=\u0026#34; + fmt.Sprintf(\u0026#34;%d-%d\u0026#34;, startRange, endRange-1) req.Header.Add(\u0026#34;Range\u0026#34;, rangeHeader) resp, err := http.DefaultClient.Do(req) if err != nil { log.Fatal(err) } defer resp.Body.Close() //设置缓冲通道避免内存使用过多 buffer := make([]byte, 10240) for { n, err := resp.Body.Read(buffer) if err != nil { if err != io.EOF { fmt.Println(\u0026#34;read buffer: \u0026#34;, err) } // 读到EOF 后，还有最后一部分数据需要处理 w.WriteAt(buffer[:n], startRange) break } w.WriteAt(buffer[:n], startRange) startRange += int64(n) } } 这样一个简单的并发下载工具就下载完成了。\n尝试用来下载一个文件，发现速度对比curl 还是快很多的，2个多g的文件2秒钟就下好了，curl 需要12秒\ncurl 下载速度 fastfetch 下载速度\n","permalink":"https://happy-park.vercel.app/zh/posts/tech/%E5%B9%B6%E5%8F%91%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/","summary":"最近工作中经常需要从阿里云oss 上将一个打包好的安装包下载到阿里云的服务器上，从阿里云oss 下载到阿里云的服务器上，如果都是同一个区的话，其","title":"并发下载工具"},{"content":" 在之前的文章 并发下载工具 的实现中使用了一个 Truncate​ 函数。这个函数就是创建了一个稀疏文件，并设置这个文件的大小。在linux 中也存在类似的命令来创建稀疏文件 truncate​。\n稀疏文件特点 当用 truncate 创建一个文件，可以查看一下该文件的信息，truncate命令可以将一个文件缩小或者扩展到某个给定的大小，如下：\n1 sudo truncate -s 3T test.txt ​\n会发现创建了一个3T 大小的test.txt 文件,但是当我们用 df -h​ 查看改文件目录下的磁盘大小的时候，其实可用文件大小是106G\n​\n为什么可以超过磁盘的大小，再用 du -sh ./test.txt​看一下文件的大小发现是0\n​\n为什么？ 使用 stat ./test.txt​ 查看文件的基本信息\n​\n可以看到size的信息显示的3T 大小，但是blocks 显示的是0 也就是说文件所占用Block的块数为0。这里 IO Block ​表示一个文件的block的大小是4096\nSize 表示的是文件大小，这个也是大多数人看到的大小； Blocks 表示的是物理实际占用空间； 其实上图展示的信息就是就是文件的元信息​。而这些元信息其实都是存放在 inode 中的。那到底什么是 inode? The Linux Information Project 上是这么说的：\nAn inode is a data structure on a filesystem on Linux and other Unix-like​operating systems that stores all the information about a file except its name and its actual data.\n从以上定义可以知道，inode其实是一种数据结构，用于存储除文件名和实际数据外的所有文件信息。\n看一下 inode 的数据结构（就以 linxu ext2 为例，该结构定义在 linux/fs/ext2/ext2.h​ 头文件中 ）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct ext2_inode { __le16 i_mode; /* File mode */ __le16 i_uid; /* Low 16 bits of Owner Uid */ __le32 i_size; /* Size in bytes */ __le32 i_atime; /* Access time */ __le32 i_ctime; /* Creation time */ __le32 i_mtime; /* Modification time */ __le32 i_dtime; /* Deletion Time */ __le16 i_gid; /* Low 16 bits of Group Id */ __le16 i_links_count; /* Links count */ __le32 i_blocks; /* Blocks count */ __le32 i_flags; /* File flags */ __le32 i_block[EXT2_N_BLOCKS];/* Pointers to blocks */ __le32 i_file_acl; /* File ACL */ __le32 i_dir_acl; /* Directory ACL */ __le32 i_faddr; /* Fragment address */ }; 一个文件包含的大多数信息，在inode 中都有保存。比如\ni_mode： 文件的权限 i_size: 文件的大小 i_ctime: 文件的创建时间 i_block[EXT2_N_BLOCKS]：blocks count 这里的 i_block[EXT2_N_BLOCKS] 就表示一个inode中包含多少个block 元素。EXT2_N_BLOCKS 是个常量，数字为15 ，表示这个数组的长度为15 .该属性直接或间接的记录了文件使用了哪些 block 块。这样，当我们需要读取一个文件的时候就可以直接根据这些索引找到block 并读取数据。\n关于详细的文件系统概念这里不赘述，从这里可以看出来，其实文件的大小只是一个 inode 属性。因此文件显示的大小和实际大小并没有直接联系。\n稀疏文件的作用 第一个作用就是方便快捷，从 并发下载工具 中就可以知道，\n创建快: 我们可以快速的创建一个几个T的文件，因为其实只是制定了文件的大小，并没有真实的写入数据，创建该文件很快， 节省空间: 下载工具都有一个暂停和继续的功能，再支持并发下载的同时，并不需要真实的创建一个这么大的空间，下载多少存储多少，节省磁盘资源。 ‍\n","permalink":"https://happy-park.vercel.app/zh/posts/tech/%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6/","summary":"在之前的文章 并发下载工具 的实现中使用了一个 Truncate​ 函数。这个函数就是创建了一个稀疏文件，并设置这个文件的大小。在linux 中也存在","title":"稀疏文件"},{"content":"上善若水。 水善利万物而不争，处众人之所恶， 故几於道。居善地，心善渊，与善仁，言善信，正善治， 事善能，动善时。夫唯不争， 故无尤。\n","permalink":"https://happy-park.vercel.app/zh/about/","summary":"上善若水。 水善利万物而不争，处众人之所恶， 故几於道。居善地，心善渊，与善仁，言善信，正善治， 事善能，动善时。夫唯不争， 故无尤。","title":"About"},{"content":"在平常工作学习中经常会用到一些开源的工具，其中一些工具就是需要你安装 Node.js，然后使用 npm install xx 来安装。之前一直以为 Node.js 就是为了解决js的包管理功能。最近去深入学习了下发现错大😅。这里记录下自己的理解\nNode.js 和 chrome 我们都知道 JavaScript t其实是一门高级编程语言，高级编程语言想要在机器上执行，就需要被编译成字解码，不同的浏览器就会实现不同的 Javascript 解释器。比如 Chrome 就是用的 V8引擎，火狐用的就是 TraceMonkey 引擎。\nNode.js 是一个基于Chrome V8引擎的JavaScript运行时环境，它提供了许多与操作系统交互的功能。\n为什么浏览器不能实现上述功能，需要专门搞一个 Node.js 来做这件事？\n但是想到这里的时候就会有一点奇怪。 那我明明已经装了Chrome, 其实我电脑上已经装了 V8 引擎了，那为啥要 Node.js 来运行呢？直接写代码让浏览器解释执行代码来进行操作不就好了吗？\n其实浏览器的设计初衷是为了提供安全的网络浏览体验，而不是为本地文件操作和系统调用提供功能。出于安全性的考虑，浏览器限制了对用户计算机的访问权限，防止恶意代码滥用用户的文件和系统资源。而且浏览器也没有提供对应的对操作系统进行系统调用的 api\nNode.js使用了一种称为”libuv”的库，它允许JavaScript程序访问文件系统、网络和系统调用等功能。相比于浏览器，Node.js在设计上更加注重服务器端和命令行应用程序的开发，提供了更多底层操作的能力。\n因此，为了实现读写本地文件和执行系统调用等功能，需要使用像Node.js这样的运行时环境，它在安全性和功能性上做了相应的权衡，以满足开发者对于更底层操作的需求。\n安装Node.js 安装nodejs是最简单的了，打开Node.js官网选择对应操作系统的包，一步步安装就好了。\n安装完成后，打开终端，输入 node -v\u0026lt;span\u0026gt; \u0026lt;/span\u0026gt;​。查看一下版本号，有输出就是安装成功了。\n​ ​\nhelloworld 安装完成之后就可以像 python 一样在命令行中断来执行简单代码逻辑的，如下图：\n​ ​\n当然也可以将代码保存在 js 文件中，直接用 node 执行 js 文件。\n1 2 3 const a=\u0026#34;hello \u0026#34; const b=\u0026#34;world\u0026#34; console.log(a+b) 将上述代码保存为 main.js 并，在终端运行 noed main.js\n​ ​\n模块化 模块化其实就是： 将 JavaScript 程序拆分为可按需导入的单独模块。比如在 nodejs中我们常常需要创建一些运行大量 JavaScript 脚本的复杂程序,这个时候将功能拆解，解耦才能更好的维护，同时提高代码的可充用性。\n下面用两个例子来解释一下，\nA.js:\n1 2 3 function getData() { console.log(\u0026#34;Function getData in A.js\u0026#34;); } B.js:\n1 2 3 function getData() { console.log(\u0026#34;Function getData in B.js\u0026#34;); } 现在，如果我们将A.js和B.js同时引入页面中，然后调用getData函数会发生命名冲突。index.html:\n1 2 3 4 5 http://A.js http://B.js \u0026lt;script\u0026gt; getData(); // 将调用哪个getData函数？ \u0026lt;/script\u0026gt; 在这种情况下，由于两个文件都定义了相同的函数名，调用getData函数时会发生冲突。为了解决这个问题，我们可以使用模块化的方式来封装代码，并将作用域限定在模块内部。\nA.js模块化重写：\n1 2 3 4 5 6 7 8 9 var A = (function() { function getData() { console.log(\u0026#34;Function getData in A.js\u0026#34;); } return { getData: getData }; })(); B.js模块化重写：\n1 2 3 4 5 6 7 8 9 var B = (function() { function getData() { console.log(\u0026#34;Function getData in B.js\u0026#34;); } return { getData: getData }; })(); 现在，我们可以在引入模块后，通过模块的命名来调用相应的函数。\nindex.html:\n1 2 3 4 5 6 http://A.js http://B.js \u0026lt;script\u0026gt; A.getData(); // Output: Function getData in A.js B.getData(); // Output: Function getData in B.js \u0026lt;/script\u0026gt; Node.JS 模块化 模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。\n模块化使用 假设我们有两个模块：math.js和app.js。math.js模块包含了一些数学操作的函数，降 add 和subtract函数封装到module.exports​对象里面， 而app.js模块将通过 require('./math.js');​ 来生成一个 math​ 对象,通过math​使用math.js​模块中的函数。\nmath.js\n1 2 3 4 5 6 7 8 9 10 function add(a, b) { return a + b; } function subtract(a, b) { return a - b; } module.exports = { add, subtract }; 在上面的示例中，我们定义了add​和subtract​函数，并使用module.exports​将它们导出为一个对象，以便其他模块可以引用它们。\n接下来，创建一个名为app.js​的文件，它将使用math.js​模块中的函数。\napp.js:\n1 2 3 4 const math = require(\u0026#39;./math.js\u0026#39;); console.log(math.add(5, 3)); // 输出: 8 console.log(math.subtract(10, 7)); // 输出: 3 在app.js​文件中，我们使用require​函数引入了math.js​模块，并将其赋值给math​变量。现在，我们可以使用math​对象来调用add​和subtract​函数，并打印它们的结果。\n包管理NPM 既然有了模块化，我们就可以把自己认为写的比较好的，比较通用的模块分享出去，提供给别人使用，js 上的这个平台就是 https://www.npmjs.com 。我们可以通过 npm (安装 NodeJS的时候就已经安装好了)将该平台上我们需要的包拉下来，这样我们就可以在项目中直接使用别人写好的代码，而不需要全部由自己来实现了。\nnpm使用 初始化 我们可以在本地创建一个文件夹 npm-demo ,进入该文件夹下，执行 npm init\n​ ​\n执行中会提示输入以下参数\npackage name: 包名，不可以有中文 version: (1.0.0)：设置当前包的版本 description: 给这个包一个描述 entry point: (index.js)：这个包的入口 test command: 测试命令 git repository: git 仓库 keywords: 关键字 author: 作者 license: 开源证书 可以一路回车，就选用默认的参数。上面执行完成后会生成一个 package.json 文件. 该文件的内容就是根据上面填写的信息生成的。\n安装一个依赖包 安装依赖包通过 npm install 命令来实现，我们可以在刚刚的文件夹下安装一个 d3 模块\n1 npm install d3 此时查看 package.json 文件就会发现多了一点内容：\n​ ​\n当然这种安装方式默认安装的是最新的版本，如果我们想要指定的版本就通过在想要的包后面加上 @xxx 的方式来指定版本号，xxx 就是想要的版本\n1 npm install d3@7.6.1 执行完成后会发现echarts版本号变成了7.6.1了\n上手使用 在上面的项目中创建一个 src 文件夹，并在文件夹中创一个 index.js\n1 2 3 4 import * as d3 from \u0026#39;d3\u0026#39;; let p = d3.select(\u0026#39;body\u0026#39;).selectAll(\u0026#39;p\u0026#39;); p.text(\u0026#39;hello world\u0026#39;); 在 npm-demo 目录下创建一个 public 文件夹，并在该文件夹下床架 index.html ：\n如果这个时候直接打开 index.html ，浏览器控制台会报错，提示存在跨域的问题：\n1 2 3 4 5 \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; http://../src/index.js \u0026lt;/body\u0026gt; index.html:1 Access to script at ‘file:///root/work/npm-demo/src/index.js’ from origin ‘null’ has been blocked by CORS policy:\n这个时候可以试着用 vscode 打开该项目并在 vscode 中安装 live Server 插件\n​ ​\n安装完成后，点击 vscode 下方工具栏中的 Go Live :\n​ ​\n他会自动启动一个服务，并访问当前的 html 页面。\n但是我们发现浏览器还是没有任何内容，打开控制台看报错是\nUncaught TypeError: Failed to resolve module specifier “echarts”. Relative references must start with either “/”, “./”, or “../”.\n这是因为，我们一开始在 index.js 中导入 d3 的方式是 ‘bare import’ (裸导入)\n1 import * as d3 from \u0026#39;d3\u0026#39;; 因为 Web 浏览器无法自行解析裸导入, 因此要解决这个方法的话，要么是使用支持裸导入的服务器web-dev-server，或者用 webpack 打包工具将项目打包后打开。\n安装 web-dev-server 在 node-demo 目录下执行以下命令安装 web/dev-server\n1 npm install --save-dev @web/dev-server 安装完成之后，编辑 package.config\n在 scripts 中加入一个键值对\n1 \u0026#34;start\u0026#34;: \u0026#34;web-dev-server --node-resolve --app-index public/index.html --open\u0026#34; ​ ​\n保存后，在终端执行\n1 npm run start ​ ​\n执行完成后就会打开浏览器，我们就能看到内容了：\n​ ​\n","permalink":"https://happy-park.vercel.app/zh/posts/tech/node.js%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","summary":"在平常工作学习中经常会用到一些开源的工具，其中一些工具就是需要你安装 Node.js，然后使用 npm install xx 来安装。之前一直以为 Node.js 就是为了解决js的包","title":"Node.js 简单学习"},{"content":"动机 外部碎片: 随着进程加载到内存和从内存退出，空闲内存空间被分为不连续的小段。假设这是内存空间还有100k，但是被分为不连续的5个20k的段，这时候，需要申请30k的内存，虽然总内存绰绰有余，但是由于内存不连续，30k内存找不到合适的地址空间，这就导致了内存浪费严重。这就出现了外部碎片的问题。\n内部碎片: 按照固定大小来分区，导致有一个内存分区是18464字节,这个时候进程需要18462字节的内存，这个时候剩下的2字节内存就无法被使用，形成了内部碎片，因为这一块内存都属于此进程了。\n逻辑地址是用户空间的针对程序员可见的内存地址，对于每个进程来说，他都是使用的是连续的内存地址，但是在实际的物理内存上，进程所存储的内存地址其实都是离散的，为了能让通过逻辑地址查找到真实的物理地址。这个时候就需要一个映射表(页表)\n分段 对于逻辑地址来说，将进程划分了：代码段、数据段、堆栈。所有的段的逻辑地址都要从0开始编号。\n段内的逻辑地址都是从0开始，在分段的情况下，逻辑地址是由两个部分构成的，分别是段号和段内位移\n优点：所有的段是离散存储在内存中的，这样可以减少外部碎片，提高内存空间的利用率 缺点：需要额外的空间(段表)，因为分段的每个进程的逻辑地址大小段是不等的，所以得知道段的起始地址以及段的限长，来将逻辑地址转换成物理地址 分页 分段是可变分区管理，分页是固定分区管理。通过将进程的逻辑地址空间和物理地址空间都分成固定大小的块，其中逻辑地址空间的块叫做:页或者页面，物理地址空间的块叫做:页框或者页帧。映射逻辑地址和物理地址的叫做页表。\n页面 将逻辑地址按照固定大小的分成的块，比如32位的操作系统，逻辑地址的最大内存空间就是4G(2的32次方)，页块的固定大小是4KB,则逻辑地址空间有(232/2^12)=2^20个页块\n页面: 包含页码和页偏移，页的大小是2的幂，页大小可以512字节到1GB不等。如果逻辑地址空间是2的m次方，而且页的大小是2的n次方(即页内偏移的大小)，则页码的大小是2的(m-n)次方。\nexample: 32位的操作系统，m就是32。内存是4G，页的大小是4k，表示的是页偏移d的大小是212，n就是12，页码的大小p就是220,m-n=20。\n页表: 是一个数组，数组的下标索引和页面的页码相对应，数组对应下标所存储的值则是内存的物理地址。\n以下表示的是如何通过一个逻辑地址找到物理内存中的正确地址。\n物理地址的计算方式是：cpu 将逻辑地址分割成页码和页偏移，通过页码 去页表中查找出对应物理内存的页框号，然后将页框号替换掉逻辑地址上的页码，再加上页偏移 就是物理地址，其中页偏移的大小就是分割的内存块的大小。\n这里abcd 属于页码0，efgh 属于页码1，ijkl属于页码2，mnop属于页码3.然后每个业内偏移最大值是4.\n这时可以查找到页表中数组下标索引是0的物理地址是5,然后因为页块的大小是4，所以物理内存的地址是5*4=20。因此a的地址是20,b的物理地址是21，c的是22 以此类推。\n同理我们以32位系统为例，一个进程的页码是2^20 个(因为一个页大小4k，就是2^12次,32-12=20)，代表着页表要存储2^20 个地址，那么一个页目录项的大小起码是2.5字节(页号有2^20，则一个页表项最大也是2^20大小，一个字节8位,所以2.5字节)，有20个连续的目录项。因此一个进程的页表最大占用2.5M (1.510241024)物理内存。\n页表总结： 操作系统会为每个进程维护一个页表的备份，根据pid 页表的作用就是将逻辑地址转换成物理地址 只有当进程被cpu运行的时候，该进程对应的页表才会被加载到cpu 上 分页会导致上下文切换 TLB(快表) 为什么要快表 页表是存放在内存当中的，因为cpu 寄存器无法存放页表的所有内容，所以cpu的寄存器中有一个指针指向内存中页表的地址，存放该指针的基址寄存机叫做PTBR(page table base register).\n有了PTBR ,当切换进程的时候就不需要将页表换来换去了，只需要切换这个寄存器中的指针就可以。\n使用上述的方案，需要访问两次内存，第一次去访问内存中的页表读取页表的内容，第二次通过页表查找出来的物理地址，去访问真实数据所在的地址。\n什么是TLB TLB(Translation Look-aside Buffer) 是一个很小的快速查找的高速缓存，是一种专门配合页表使用的缓存.\nTLB 包含了一部分的页表内容(将若干个进程的页表中的某一些部分yebi放到TLB中) cpu 读逻辑地址的时候需要将逻辑地址转换成物理地址，这个时候他先去TLB中这个页表项是否存在，如果存在则，可以立刻可以直接转换成物理地址，去访问数据，如果不存在，则再去内存中访问该进程的页表。 ","permalink":"https://happy-park.vercel.app/zh/posts/tech/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E9%A1%B5%E5%88%86%E8%A1%A8/","summary":"动机 外部碎片: 随着进程加载到内存和从内存退出，空闲内存空间被分为不连续的小段。假设这是内存空间还有100k，但是被分为不连续的5个20k的段","title":"操作系统分页分表"}]